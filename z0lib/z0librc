# -*- coding: utf-8 -*-
#
# Copyright (C) SHS-AV s.r.l. (<http://ww.zeroincombenze.it>)
# This software is free software under GNU Affero GPL3
# Bash general purpose library
#__version__=0.2.8
STS_FAILED=1
STS_SUCCESS=0
PYPATH=$(echo -e "import sys\nprint(str(sys.path).replace(' ','').replace('\"','').replace(\"'\",\"\").replace(',',':')[1:-1])"|python)

##############################################################################
# Install this lib file in /etc if version is more recent
# This must be in the same directory of caller script
_install_z0librc() {
    local tgt=/etc/z0librc
    local src=./z0librc
    local xtl=0
    if [ -f $src ]; then
      if [ -f $tgt ]; then
        if [ "$1" == "-n" ]; then
          local xtlver=$(echo "#__version__=0.1.1"|grep -Eo '[0-9]+\.[0-9]+(\.[0-9]+|)'|awk -F. '{print $1*10000 + $2*100 + $3}')
        else
          local xtlver=$(grep "#__version__" $tgt|head -n1|grep -Eo '[0-9]+\.[0-9]+(\.[0-9]+|)'|awk -F. '{print $1*10000 + $2*100 + $3}')
          if [ -z "$xtver" ]; then xtlver="0"; fi
        fi
        local newver=$(grep "#__version__" $src|head -n1|grep -Eo '[0-9]+\.[0-9]+(\.[0-9]+|)'|awk -F. '{print $1*10000 + $2*100 + $3}')
        if [ -z "$newver" ]; then newver="0"; fi
        if [ $newver -gt $xtlver ]; then
          xtl=1
        fi
      else
        xtl=1
      fi
      if [ $xtl -gt 0 ]; then
        if [ "$1" == "-n" ]; then
          echo "cp $src $tgt"
        elif [ $EUID -eq 0 ]; then
          cp $src $tgt
        fi
      fi
    fi
}
export -f _install_z0librc


##############################################################################
# Detect and print more OS informations than uname command
# __version__=0.1.6
# Print Linux OS system information in same way of uname command
# but returns more information.
# Based on Novell article http://www.novell.com/coolsolutions/feature/11251.html
# Credits:
# - Arun Singh (Novell Senior Software Engineer)
# - antoniomaria.vigliotti@gmail.com (zeroincombenze® Senior Software Engineer)
# - giuliano69 (https://github.com/Giuliano69/odoo_install/blob/master/odoo8_install.sh)
#
# Check history
#    Date        Author      Result of xname -a -> xname -f
#    2015-08-27  antoniov    Linux CentOS 6.7(Final 2.6.32-504.16.2.el6.x86_64 x86_64) -> RHEL
#    2015-08-27  antoniov    Linux CentOS 7.1.1503(Core 3.10.0-229.1.2.el7.x86_64 x86_64) -> RHEL
#    2015-08-27  antoniov    Linux Ubuntu 12.04( 3.13.0-32-generic i686) -> Debian
#    2015-09-15  antoniov    Linux Ubuntu 14.04(trusty 3.13.0-66-generic x86_64) -> Debian
#    2015-10-28  antoniov    Linux VMWare VMware(VMware ESX Server 3 2.4.21-57.ELvmnix i686) -> VMWare
#    2017-12-07  antoniov    Linux 3.2.0-4-amd64 #1 SMP Debian 3.2.96-2 x86_64 GNU/Linux -> Debian
#    2017-12-07  antoniov    Linux 3.10.0-693.5.2.el7.x86_64 #1 x86_64 x86_64 x86_64 GNU/Linux -> Debian
#    2017-12-07  antoniov    Linux 3.16.0-4-amd64 #1 SMP Debian 3.16.7-ckt9-3~deb8u1 (2015-04-24) x86_64 GNU/Linux -> Debian
#
# Parameter $1:
#   -a  print all
#   -d  print Linux distribution name (empty on Unix)
#   -f  print Linux family (RHEL or Debian, empty on Unix)
#   -k  print Linux kernel release (on Unix same as -r)
#   -m  print machine hardware name
#   -p  print processor architecture
#   -r  print kernel release
#   -v  print distribution version (only on Linux)
xuname() {
# You can find more help about this function on
# http://wiki.zeroincombenze.org/en/Linux/dev
  if [ "$(echo :$SHELLOPTS:|grep :xtrace: 2>/dev/null)" ]; then set +x; local SET_X="set -x"; else local SET_X=; fi
  OS=$(uname -s)
  REV=$(uname -r)
  MACH=$(uname -m)
  KERNEL="$REV"
  VER=""
  DIST=""
  ARCH=$(uname -p)
  FAMILY=""
  XDES=""

  if [ "${OS}" = "SunOS" ]; then
    OS=Solaris
    ARCH=$(uname -p)
    VER=$(uname -v)
    OSSTR="${OS} ${REV}(${ARCH} $(uname -v))"
  elif [ "${OS}" = "AIX" ]; then
    OSSTR="${OS} $(oslevel) ($(oslevel -r))"
  elif [ "${OS}" = "Linux" ]; then
    KERNEL=$(uname -r)
    CODENAME=""
    if [ -f /etc/vmware-release ]; then
      DIST='VMWare'
      CODENAME=$(cat /etc/vmware-release | sed s/.*\(// | sed s/\)//)
      VER=$(cat /etc/vmware-release | sed s/.*release\ // | sed s/\ .*//)
    elif [ -f /etc/centos-release ]; then
      DIST='CentOS'
      XDES=$(cat /etc/centos-release|tr -d " \n")
      CODENAME=$(cat /etc/centos-release | sed s/.*\(// | sed s/\)//)
      VER=$(cat /etc/centos-release | sed s/.*release\ // | sed s/\ .*//)
      FAMILY="RHEL"
    elif [ -f /etc/gentoo-release ]; then
      DIST='Gentoo'
      CODENAME=$(cat /etc/gentoo-release | sed s/.*\(// | sed s/\)//)
      VER=$(cat /etc/gentoo-release | sed s/.*release\ // | sed s/\ .*//)
    elif [ -f /etc/redhat-release ]; then
      DIST='RedHat'
      CODENAME=$(cat /etc/redhat-release | sed s/.*\(// | sed s/\)//)
      VER=$(cat /etc/redhat-release | sed s/.*release\ // | sed s/\ .*//)
      FAMILY="RHEL"
    elif [ -f /etc/SUSE-release ]; then
      DIST="SuSE"
      CODENAME=$(cat /etc/SUSE-release | tr "\n" ' '| sed s/VERSION.*//)
      VER=$(cat /etc/SUSE-release | tr "\n" ' ' | sed s/.*=\ //)
      FAMILY="RHEL"
    elif [ -f /etc/SuSE-release ]; then
      DIST="SuSE"
      CODENAME=$(cat /etc/SuSE-release | tr "\n" ' '| sed s/VERSION.*//)
      VER=$(cat /etc/SuSE-release | tr "\n" ' ' | sed s/.*=\ //)
      FAMILY="RHEL"
    elif [ -f /etc/mandriva-release ]; then
      DIST='Mandriva'
      CODENAME=$(cat /etc/mandriva-release | sed s/.*\(// | sed s/\)//)
      VER=$(cat /etc/mandriva-release | sed s/.*release\ // | sed s/\ .*//)
      FAMILY="RHEL"
    elif [ -f /etc/mandrake-release ]; then
      DIST='Mandrake'
      CODENAME=$(cat /etc/mandrake-release | sed s/.*\(// | sed s/\)//)
      VER=$(cat /etc/mandrake-release | sed s/.*release\ // | sed s/\ .*//)
    elif [ -f /etc/fedora-release ]; then
      DIST="Fedora"
      CODENAME=$(cat /etc/fedora-release | sed s/.*\(// | sed s/\)//)
      VER=$(cat /etc/fedora-release | sed s/.*release\ // | sed s/\ .*//)
      FAMILY="RHEL"
    elif [ -f /etc/slackware-version ]; then
      DIST="Slackware"
      VER=""
    elif [ -f /etc/lsb-release -o -d /etc/lsb-release.d ]; then
      DIST=$(grep "DISTRIB_ID" /etc/lsb-release|awk -F"=" '{print $2}'|tr -d "\"', \n")
      if [ -z "$DIST" ]; then
        DIST="Ubuntu"
      fi
      VER=$(grep "DISTRIB_RELEASE" /etc/lsb-release|awk -F"=" '{print $2}'|tr -d "\"', \n")
      CODENAME=$(grep "DISTRIB_CODENAME" /etc/lsb-release|awk -F"=" '{print $2}'|tr -d "\"', \n")
      XDES=$(grep "DISTRIB_DESCRIPTION" /etc/lsb-release|awk -F"=" '{print $2}'|tr -d "\"', \n")
      FAMILY="Debian"
    elif [ -f /etc/debian_version ]; then
      DIST="Debian"
      ls_relase &>/dev/null
      [ $? -ne 127 ] && VER=$(lsb_release --release --short) || VER=$(cat /etc/debian_version)
      FAMILY="Debian"
    elif [ -f /etc/os-release ]; then
      DIST="Debian"
      ls_relase &>/dev/null
      [ $? -ne 127 ] && VER=$(lsb_release --release --short) || VER=$(cat /etc/os-release)
      FAMILY="Debian"
    fi
    if [ -f /etc/UnitedLinux-release ]; then
      DIST="${DIST}[$(cat /etc/UnitedLinux-release | tr "\n" ' ' | sed s/VERSION.*//)]"
    fi
    OSSTR="${OS} ${DIST} ${VER}(${CODENAME} ${KERNEL} ${MACH})"
  fi
  if [ "$1" == "-c" ]; then
    echo ${CODENAME}
  elif [ "$1" == "-d" ]; then
    echo ${DIST}
  elif [ "$1" == "-f" ]; then
    echo ${FAMILY}
  elif [ "$1" == "-k" ]; then
    echo ${KERNEL}
  elif [ "$1" == "-m" -o  "$1" == "-i" ]; then
    echo ${MACH}
  elif [ "$1" == "-p" ]; then
    echo ${ARCH}
  elif [ "$1" == "-s" ]; then
    echo ${OS}
  elif [ "$1" == "-r" ]; then
    echo ${REV}
  elif [ "$1" == "-v" ]; then
    echo ${VER}
  elif [ "$1" == "-x" ]; then
    echo ${XDES}
  else
    echo ${OSSTR}
  fi
  $SET_X
}
export -f xuname




##############################################################################
# Parse command line arguments in a professional way
# __version__="0.1.9"
# You can define syntax rules declaring some array variables, before calling
# this function. On exit, variable are set on appropriate way.
# Global variables to declare
#   OPTOPTS  array with option switch characters (do not forget h for help)
#      Common option (without -, description and default variable):
#      h help       Show help               opt_help
#      n no         Do nothing (only test)  opt_dry_run
#      V version    Show app version        opt_version
#   OPTLONG  array with long option (with double dash)
#      Common option (description and default variable):
#      --help       Show help               opt_help
#      --dry-run    Do nothing (only test)  opt_dry_run
#      --version    Show app version        opt_version
#   OPTDEST  array of destination variables (matches one to one OPTOPTS)
#      Recommend variables:
#      opt_help     show help (int)
#      opt_version  show app version (string)
#      opt_dry_run  do nothing (int)
#   OPTACTI  array of action (matches one to one OPTOPTS)
#      1.st character:
#      0    Set variable to zero (false)
#      1    Set variable to 1 (true)
#      +    Increase variable value (like -vv for more verbose)
#      *    Set variable with option switch name itself (i.e. -h)
#      =    Set variable to following option value
#      2.nd character:
#      >    executive command (disable help and version)
#   OPTDEFL  array with default values, '#' means no default value (matches one to one OPTOPTS)
#   OPTMETA  array with meta help to build help (matches one to one OPTOPTS)
#   OPTHELP  array with parameters description to build help (matches one to one OPTOPTS)
#   OPTARGS  array of destination variables of positional arguments (set OPTARGS=() if no args)
#
parseoptargs() {
# You can find more help about this function on
# http://wiki.zeroincombenze.org/en/Linux/dev
    local jy=0 f=0 a b v
    while ((jy<${#OPTDEST[*]})); do
      if [ "${OPTDEFL[jy]}" != "#" ]; then
        export ${OPTDEST[jy]}="${OPTDEFL[jy]}"
      fi
      ((++jy))
    done
    local jy=0
    while ((jy<${#OPTARGS[*]})); do
      export ${OPTARGS[jy]}=""
      ((++jy))
    done
    local kk=0
    local ii=1
    local failed=0
    while ((ii<=$#)); do
      local oo="${!ii}"
      if [ "${oo:0:2}" == "--" -a "$o" != "--" ]; then
        IFS== read a v <<<$oo
        jy=0
        f=0
        while ((jy<${#OPTLONG[*]})); do
          if [ "${a:2}" == ${OPTLONG[jy]} ]; then
            f=1
            a=${OPTACTI[jy]}
            b=${a:1:1}
            if [ "$b" == ">" ]; then
               export opt_help=0
               export opt_version=""
            fi
            a=${a:0:1}
            if [ "$a" == "0" -o "$a" == "1" ]; then
              export ${OPTDEST[jy]}=$a
            elif [ "$a" == "+" ]; then
              if [ ${!OPTDEST[jy]} -lt 0 ]; then export ${OPTDEST[jy]}=0; fi
              ((${OPTDEST[jy]}++))
              export ${OPTDEST[jy]}
            elif [ "$a" == "=" ]; then
              if [ -n "$v" ]; then
                export ${OPTDEST[jy]}=$v
              else
                ((++ii))
                export ${OPTDEST[jy]}="${!ii}"
              fi
            fi
            jy=${#OPTOPTS[*]}
          else
            ((++jy))
          fi
        done
        if [ $f -eq 0 ]; then
          local failed=1
        fi
      elif [ "${oo:0:1}" == "-" ]; then
        local jj=1
        while ((jj<${#oo})); do
          jy=0
          f=0
          while ((jy<${#OPTOPTS[*]})); do
            if [ "${oo:jj:1}" == ${OPTOPTS[jy]} ]; then
              # set -x
              f=1
              a=${OPTACTI[jy]}
              b=${a:1:1}
              if [ "$b" == ">" ]; then
                 export opt_help=0
                 export opt_version=""
              fi
              a=${a:0:1}
              if [ "$a" == "0" -o "$a" == "1" ]; then
                export ${OPTDEST[jy]}=$a
              elif [ "$a" == "*" ]; then
                export ${OPTDEST[jy]}="-${oo:jj:1}"
              elif [ "$a" == "+" ]; then
                if [ ${!OPTDEST[jy]} -lt 0 ]; then export ${OPTDEST[jy]}=0; fi
                ((${OPTDEST[jy]}++))
                export ${OPTDEST[jy]}
              elif [ "$a" == "=" ]; then
                ((++jj))
                export ${OPTDEST[jy]}=${oo:jj}
                a="${!OPTDEST[jy]}"
                if [ -n "$a" ]
                then
                  jj=${#oo}
                else
                  ((++ii))
                  export ${OPTDEST[jy]}="${!ii}"
                fi
              fi
              jy=${#OPTOPTS[*]}
            else
              ((++jy))
            fi
          done
          if [ $f -eq 0 ]; then
            local failed=1
            break
          fi
          ((++jj))
          # set +x
        done
      elif [ "$oo" ]; then
        export ${OPTARGS[kk]}="$oo"
        export opt_help=0
        export opt_version=""
        ((++kk))
      fi
      ((++ii))
    done
    if [ $failed -gt 0 ]; then
      export opt_help=1
    fi
    if [ ${opt_verbose:-0} -eq -1 ]; then
      if [ "$VERBOSE_MODE" == "1" -o "$VERBOSE_MODE" == "0" ]; then
        opt_verbose=$VERBOSE_MODE
      elif [[ -t 0 || -p /dev/stdin ]]; then
        opt_verbose=0
      else
        opt_verbose=1
      fi
    fi
}
export -f parseoptargs


# Print help for parse command line arguments
# __version__="0.1.9"
print_help() {
# You can find more help about this function on
# http://wiki.zeroincombenze.org/en/Linux/dev
    local txt="Usage: "
    local hlp=""
    txt+="$(basename $0) "
    local xx="[-"
    local jy=0
    while ((jy<${#OPTOPTS[*]})); do
      local a=${OPTACTI[jy]}
      a=${a:0:1}
      if [ "$a" == "0" -o "$a" == "1" -o "$a" == "+" -o "$a" == "*" ]; then
        if [ "$xx" == "]" ]; then
          xx="][-"
        fi
        txt+="$xx${OPTOPTS[jy]}"
        xx=""
        hlp+=$(printf ' %-16.16s%s%s' "-${OPTOPTS[jy]}" "${OPTHELP[jy]}" '\n')
      elif [ "$a" == "=" ]; then
        if [ -z "$xx" -o "$xx" == "]" ]; then
          xx="][-"
        fi
        txt+="$xx${OPTOPTS[jy]} ${OPTMETA[jy]}"
        xx="]"
        hlp+=$(printf '%3.3s %-13.13s%s%s' "-${OPTOPTS[jy]}" "${OPTMETA[jy]}" "${OPTHELP[jy]}" '\n')
      fi
      ((++jy))
    done
    if [ -z "$xx" ]; then
      xx="]"
    fi
    txt+="$xx"
    jy=0
    while ((jy<${#OPTARGS[*]})); do
      txt+=" ${OPTARGS[jy]}"
      ((++jy))
    done
    echo -e "$txt"
    echo -e "$1"
    echo -e "$hlp"
    echo -e "$2"
}
export -f print_help



##############################################################################
# Set tracelog filename for wlog function
# Log message may be echoed onto console ($3=echo)
# log filename may be /dev/null
#
# Parameter $1:
#    Filename to write (may be full pathname or just basename)
# Parameter $2:
#    "new" means create a new file log, otherwise append to existent file
# Parameter $3:
#    "echo" means wlog echoes message onto console when write log
set_tlog_file() {
    #set -x
    local p=$(dirname "$1")
    local f=$(basename "$1")
    if [ "$p" == "~" ]; then p=$HOME; fi
    if [ "$p" == "." -a "${1:0:2}" != "./" ]; then p=""; fi
    if [ -z "$p" ]; then
      if [ $EUID -eq 0 ]; then
        p=/var/log
      else
        p=$HOME
      fi
    fi
    export FLOG=$(readlink -f $p/$f)
    if [ "$2" == "new" ]; then
      if [ -f "$FLOG" ]; then rm -f "$FLOG"; fi
    fi
    export FLOG_ECHO=${3:-#}
    #set +x
}


##############################################################################
# Write log on file $FLOG: see set_tlog_file function
wlog() {
    local dt=$(date +"%F %H:%M:%S")
    if [ -n "$FLOG" ]; then
      echo $dt "$@">>$FLOG
    fi
    if [ "$FLOG_ECHO" == "echo" ]; then
      $FLOG_ECHO -e "$@"
    fi
}
export -f wlog

##############################################################################
# Write log on file $FLOG without echo
slog() {
    local dt=$(date +"%F %H:%M:%S")
    if [ -n "$FLOG" ]; then
      echo $dt "$@">>$FLOG
    fi
}
export -f wlog

##############################################################################
# Echo meassage and write log on file $FLOG: see set_tlog_file function
elog() {
    wlog "$@"
    if [ "$FLOG_ECHO" != "echo" ]; then
      echo -e "$@"
    fi
}
export -f elog

##############################################################################
# Log message if error level (opt_verbose=2)
wlog_error() {
    [ ${opt_verbose:-0} -ge 2 ] && wlog "$@"
}
elog_error() {
    [ ${opt_verbose:-0} -ge 2 ] && elog "$@"
}

# Log message if warning level (opt_verbose=3)
wlog_warning() {
    [ ${opt_verbose:-0} -ge 3 ] && wlog "$@"
}
elog_warning() {
    [ ${opt_verbose:-0} -ge 3 ] && elog "$@"
}

# Log message if info level (opt_verbose=4)
wlog_info() {
    [ ${opt_verbose:-0} -ge 4 ] && wlog "$@"
}
elog_info() {
    [ ${opt_verbose:-0} -ge 4 ] && elog "$@"
}

# Log message if debug level (opt_verbose=5)
wlog_debug() {
    [ ${opt_verbose:-0} -ge 5 ] && wlog "$@"
}
elog_debug() {
    [ ${opt_verbose:-0} -ge 5 ] && elog "$@"
}


##############################################################################
# Execute line commad and trace in tracelog
#
# Global variables to declare (base on parseoptargs):
# - opt_dry_run (-n): if > 0 do not execute command, just log
# - opt_verbose (-v): echo command line before execution
# Parameter $1:
#    command line with parameters; command may be a comment (beginning with '#')
#    command 'cd ' is always executed, also if dry_run
# Parameter $2:
#    execute as user; caller must be sudoer
# Parameter $3:
#    do login (1) if execute as user
run_traced() {
    if [ "$(echo :$SHELLOPTS:|grep :xtrace: 2>/dev/null)" ]; then set +x; local SET_X="set -x"; else local SET_X=; fi
    local xcmd="$1"
    local sts=$STS_SUCCESS
    if [ -n "$2" -a "$2" != "$USER" ]; then
      if [ ${3:-0} -gt 0 ]; then
        xcmd="sudo -iu$2 $1"
      else
        xcmd="sudo -u$2 $1"
      fi
    fi
    local pfx=
    if [ "${1:0:1}" == "#" ]; then
      pfx=
    elif [ ${opt_dry_run:-0} -eq 0 ]; then
      pfx="\$ "
    else
      pfx="> "
    fi
    if [ ${opt_dry_run:-0} -eq 0 ]; then
      if [ "${1:0:5}" != "wlog " ];then
        if [ ${opt_verbose:-0} -gt 0 ]; then
          elog "$pfx$xcmd"
        else
          wlog "$pfx$xcmd"
        fi
      fi
      if [ "${1:0:1}" != "#" ]; then
        eval "$xcmd"
        sts=$?
      fi
    elif [ "${1:0:6}" != "sleep " ]; then
      if [ ${opt_verbose:-0} -gt 0 ]; then
        echo "$pfx$xcmd"
      fi
      if [ "${1:0:3}" == "cd " -o "$1" == "cd" ]; then
        eval "$xcmd" 2>/dev/null
      fi
    fi
    $SET_X
    return $sts
}

export -f run_traced


##############################################################################
# Parse directory to search a file
# __version__="0.1.1"
# Search a file o directory of a list.
# This function is used to find where is an application.
#
# Parameter $1:
#    File to search (if null is searched just for directory of $2 ...)
# Parameter $2:
#    Directory list (space separated) where file could be found (mandatory)
# Parameter $3:
#    Level 2 subdirectory list (space separated) where file could be found (mayby be empty)
# Parameter $4:
#    Level 3 subdirectory list (space separated) where file could be found (mayby be empty)
# Parameter $5:
#    Level 4 subdirectory list (space separated) where file could be found (mayby be empty)
# Parameter $6:
#    Level 5 subdirectory list (space separated) where file could be found (mayby be empty)
findpkg() {
    if [ "$(echo :$SHELLOPTS:|grep :xtrace: 2>/dev/null)" ]; then set +x; local SET_X="set -x"; else local SET_X=; fi
    local p2=
    local p3=
    local p4=
    local p5=
    local p6=
    local r2=
    local r3=
    local r4=
    local r5=
    local r6=
    local result=
    for p2 in $2; do
      r2=$p2
      for p3 in $3 .; do
        if [ "$p3" == "." ]; then r3=; else r3=/$p3; fi
        for p4 in $4 .; do
          if [ "$p4" == "." ]; then r4=; else r4=/$p4; fi
          for p5 in $5 .; do
            if [ "$p5" == "." ]; then r5=; else r5=/$p5; fi
            for p6 in $6 .; do
              if [ "$p6" == "." ]; then r6=; else r6=/$p6; fi
              if [ -z "$1" ]; then
                if [ -d $r2$r3$r4$r5$r6 ]; then
                  result=$(readlink -e $r2$r3$r4$r5$r6)
                  break
                fi
              else
                if [ -e $r2$r3$r4$r5$r6/$1 ]; then
                  result=$(readlink -e $r2$r3$r4$r5$r6/$1)
                  break
                fi
              fi
            done
            if [ -n "$result" ]; then break; fi
          done
          if [ -n "$result" ]; then break; fi
        done
        if [ -n "$result" ]; then break; fi
      done
      if [ -n "$result" ]; then break; fi
    done
    echo "$result"
    $SET_X
}
export -f findpkg


# Deprecated: use CFG_init
a_new() {
    if [ "$1" == "0" -o "$1" == "1" -o "$1" == "2" -o "$1" == "3" ]; then
      local tid=$1
    else
      local tid="0"
    fi
    cmd="unset DEFDICT$tid DEFRULE$tid"
    echo $cmd
}
export -f a_new



# Deprecated: use CFG_init
a_active() {
    if [ "$(echo :$SHELLOPTS:|grep :xtrace: 2>/dev/null)" ]; then set +x; local SET_X="set -x"; else local SET_X=; fi
    if [ "$1" == "0" -o "$1" == "1" -o "$1" == "2" -o "$1" == "3" ]; then
      local tid=$1
    else
      local tid="0"
    fi
    if [ "$XU_FH" != "RHEL" -a "$XU_FH" != "Debian" ]; then
      XU_FH=$(xuname "-f")
      local x=$(xuname "-v")
      local v=$(echo $x|awk -F. '{print $1}')
      XU_DISTO=$(xuname "-d")$v
    elif [ -z "$XU_DISTO" ]; then
      local x=$(xuname "-v")
      XU_DISTO=$(xuname "-d")${x:0:1}
    fi
    # declare -g XU_FH=$XU_FH XU_DISTO=$XU_DISTO
    # declare -gA DEFDICT$tid DEFRULE$tid
    cmd="XU_FH=$XU_FH XU_DISTO=$XU_DISTO; declare -gA DEFDICT$tid DEFRULE$tid"
    echo $cmd
    $SET_X
}
export -f a_active


##############################################################################
# Add key and value to dictionary (associative array)
# key may be regex to match multiple values
# It's a ugly solution but currently works
# __version__="0.1.5"
# Global variables declared by CFG_init
#   DEFDICT  global dictionary based on unique key (associative array)
#   DEFRULE  global dictionary based on regex (associative array)
#   XU_DISTO contains distribution id (to search key of specific Linux Distribution)
#   XU_FH    contains Linux Family id (see xuname)
# Parameter $1:
#    Id of table (may be 0..3)
# Parameter $2:
#    Dictionary key; if begin with "^" is a regex, otherwise is unique key
# Parameter $3:
#    Dictionary value
# Parameter $4:
#    "-d"   key is specific of Linux distribution
#    "-f"   key is specific of Linux family
#    not "" specific Linux distribution or family
# Parameter $5:
#    "-D|1"   key is specific for development environment
# Parameter $6:
#    Section (reserved ti future use)
CFG_set() {
    if [ "$(echo :$SHELLOPTS:|grep :xtrace: 2>/dev/null)" ]; then set +x; local SET_X="set -x"; else local SET_X=; fi
    # if [[ "$3" =~ "[0123]" ]]; then
    local tid=$3
    # else
    #   local tid="3"
    # fi
    if [ -n "$2" ]; then
      if [ "$4" == "-d" ]; then
        local SFX="__$XU_DISTO"
      elif [ "$4" == "-f" ]; then
        local SFX="__$XU_FH"
      elif [ -n "$4" ]; then
        local SFX="__$4"
      else
        local SFX=
      fi
      local key=${2//-/_}
      if [[ $5 =~ (D|1) ]]; then
        local SFX="${SFX}__DEV"
      fi
      if [ "$1" == "0" ]; then
        if [ "${key:0:1}" == "^" ]; then
          DEFRULE0[$key$SFX]="$3"
        else
          DEFDICT0[$key$SFX]="$3"
        fi
      elif [ "$1" == "1" ]; then
        if [ "${key:0:1}" == "^" ]; then
          DEFRULE1[$key$SFX]="$3"
        else
          DEFDICT1[$key$SFX]="$3"
        fi
      elif [ "$1" == "2" ]; then
        if [ "${key:0:1}" == "^" ]; then
          DEFRULE2[$key$SFX]="$3"
        else
          DEFDICT2[$key$SFX]="$3"
        fi
      elif [ "$1" == "3" ]; then
        if [ "${key:0:1}" == "^" ]; then
          DEFRULE3[$key$SFX]="$3"
        else
          DEFDICT3[$key$SFX]="$3"
        fi
      fi
    fi
    $SET_X
}
export -f CFG_set

# Deprecated: use CFG_set
a_add() {
    CFG_set "$@"
}

##############################################################################
# Find value in associative array
# It's a ugly solution but currently works
# __version__="0.1.5"
# Global variables create by a_append
#   DEFDICT  global dictionary based on unique key (associative array)
#   DEFRULE  global dictionary based on regex (associative array)
#   XU_DISTO contains distribution id (to search key of specific Linux Distribution)
#   XU_FH    contains Linux Family id (see xuname)
# Parameter $1:
#    Id of table (may be 0..3)
# Parameter $2:
#    Dictionary key to search
# Return:
#    dictionary value to stdout
#    status
CFG_find() {
    if [ "$(echo :$SHELLOPTS:|grep :xtrace: 2>/dev/null)" ]; then set +x; local SET_X="set -x"; else local SET_X=; fi
    local p=""
    local sts=1
    local x SFX key KK
    if [ -n "$2" ]; then
      SFX=
      key=${2//-/_}
      if [ "$1" == "0" ]; then
        for SFX in __${XU_DISTO}__DEV __${XU_FH}__DEV __$XU_DISTO __$XU_FH ""; do
          KK=$key$SFX
          p=${DEFDICT0[$KK]}
          if [ -n "$p" ]; then break; fi
        done
        if [ -z "$p" ]; then
          local KK=(${!DEFRULE0[@]})
          local SFX=
          for SFX in __${XU_DISTO}__DEV __${XU_FH}__DEV __$XU_DISTO __$XU_FH ""; do
            local jy=0
            while ((jy<${#DEFRULE0[@]})); do
              local K=${KK[$jy]}
              if [[ "$K" =~ ^.*$SFX ]]; then
                if [[ "${key}__$XU_DISTO" =~ $K ]]; then
                  p=${DEFRULE0[$K]}
                  local sts=0
                  break
                elif [[ "${key}__$XU_FH" =~ $K ]]; then
                  p=${DEFRULE0[$K]}
                  local sts=0
                  break
                fi
              fi
              ((jy++))
            done
            if [ $sts -eq $STS_SUCCESS ]; then break; fi
          done
        fi
      elif [ "$1" == "1" ]; then
        for SFX in __${XU_DISTO}__DEV __${XU_FH}__DEV __$XU_DISTO __$XU_FH ""; do
          KK=$key$SFX
          p=${DEFDICT1[$KK]}
          if [ -n "$p" ]; then break; fi
        done
        if [ -z "$p" ]; then
          local KK=(${!DEFRULE1[@]})
          local SFX=
          for SFX in __${XU_DISTO}__DEV __${XU_FH}__DEV __$XU_DISTO __$XU_FH ""; do
            local jy=0
            while ((jy<${#DEFRULE1[@]})); do
              local K=${KK[$jy]}
              if [[ "$K" =~ ^.*$SFX ]]; then
                if [[ "${key}__$XU_DISTO" =~ $K ]]; then
                  p=${DEFRULE1[$K]}
                  local sts=0
                  break
                elif [[ "${key}__$XU_FH" =~ $K ]]; then
                  p=${DEFRULE1[$K]}
                  local sts=0
                  break
                fi
              fi
              ((jy++))
            done
            if [ $sts -eq $STS_SUCCESS ]; then break; fi
          done
        fi
      elif [ "$1" == "2" ]; then
        for SFX in __${XU_DISTO}__DEV __${XU_FH}__DEV __$XU_DISTO __$XU_FH ""; do
          KK=$key$SFX
          p=${DEFDICT2[$KK]}
          if [ -n "$p" ]; then break; fi
        done
        if [ -z "$p" ]; then
          local KK=(${!DEFRULE2[@]})
          local SFX=
          for SFX in __${XU_DISTO}__DEV __${XU_FH}__DEV __$XU_DISTO __$XU_FH ""; do
            local jy=0
            while ((jy<${#DEFRULE2[@]})); do
              local K=${KK[$jy]}
              if [[ "$K" =~ ^.*$SFX ]]; then
                if [[ "${key}__$XU_DISTO" =~ $K ]]; then
                  p=${DEFRULE2[$K]}
                  local sts=0
                  break
                elif [[ "${key}__$XU_FH" =~ $K ]]; then
                  p=${DEFRULE2[$K]}
                  local sts=0
                  break
                fi
              fi
              ((jy++))
            done
            if [ $sts -eq $STS_SUCCESS ]; then break; fi
          done
        fi
      elif [ "$1" == "3" ]; then
        for SFX in __${XU_DISTO}__DEV __${XU_FH}__DEV __$XU_DISTO __$XU_FH ""; do
          KK=$key$SFX
          p=${DEFDICT3[$KK]}
          if [ -n "$p" ]; then break; fi
        done
        if [ -z "$p" ]; then
          local KK=(${!DEFRULE3[@]})
          local SFX=
          for SFX in __${XU_DISTO}__DEV __${XU_FH}__DEV __$XU_DISTO __$XU_FH ""; do
            local jy=0
            while ((jy<${#DEFRULE3[@]})); do
              local K=${KK[$jy]}
              if [[ "$K" =~ ^.*$SFX ]]; then
                if [[ "${key}__$XU_DISTO" =~ $K ]]; then
                  p=${DEFRULE3[$K]}
                  local sts=0
                  break
                elif [[ "${key}__$XU_FH" =~ $K ]]; then
                  p=${DEFRULE3[$K]}
                  local sts=0
                  break
                fi
              fi
              ((jy++))
            done
            if [ $sts -eq $STS_SUCCESS ]; then break; fi
          done
        fi
      fi
      if [ -n "$p" ]; then
        local sts=0
      fi
    fi
    echo "$p"
    $SET_X
    return $sts
}
export -f CFG_find

# Deprecated: use CFG_find
a_find() {
    CFG_find "$@"
}

##############################################################################
# get value from config file
# if file does not exist, or parameter does not exist, return default value
# __version__="0.1.1"
# Require CFG_find
#   DEFDICT  global dictionary based on unique key (associative array)
#   DEFRULE  global dictionary based on regex (associative array)
#   XU_DISTO contains distribution id (to search key of specific Linux Distribution)
#   XU_FH    contains Linux Family id (see xuname)
# Parameter $1:
#    Id of table (may be 0..3)
# Parameter $2:
#    Parameter key to search
# Return:
#    parameter value
get_cfg_value() {
    local p
    if [ -z "$2" ]; then
      p=
      echo $p
      return
    else
      p=
    fi
    if [ "$1" == "0" -o "$1" == "1" -o "$1" == "2" -o "$1" == "3" ]; then
      local tid=$1
    else
      local tid="0"
    fi
    if [ -z "$p" -o "$p" == "False" ]; then
      p=$(CFG_find "$tid" "$2")
    fi
    if [ "$p" == "None" ]; then
      p=
    fi
    echo "$p"
}
export -f get_cfg_value


##############################################################################
# Create empty dictionary (based on associative array)
# __version__="0.2.0"
# Globals:
#   DEFDICT  global dictionary based on unique key (associative array)
#   DEFRULE  global dictionary based on regex (associative array)
#   XU_DISTO contains distribution id (to search key of specific Linux Distribution)
#   XU_FH    contains Linux Family id (see xuname)
# Parameter $1:
#    Id of table for access
CFG_init() {
    if [ "$(echo :$SHELLOPTS:|grep :xtrace: 2>/dev/null)" ]; then set +x; local SET_X="set -x"; else local SET_X=; fi
    if [ "$1" == "0" -o "$1" == "1" -o "$1" == "2" -o "$1" == "3" ]; then
      local tid=$1
    else
      local tid="0"
    fi
    unset DEFDICT$tid DEFRULE$tid
    if [ "$XU_FH" != "RHEL" -a "$XU_FH" != "Debian" ]; then
      XU_FH=$(xuname "-f")
      local x=$(xuname "-v")
      local v=$(echo $x|awk -F. '{print $1}')
      XU_DISTO=$(xuname "-d")$v
    elif [ -z "$XU_DISTO" ]; then
      local x=$(xuname "-v")
      XU_DISTO=$(xuname "-d")${x:0:1}
    fi
    declare -g XU_FH=$XU_FH XU_DISTO=$XU_DISTO
    declare -gA DEFDICT$tid DEFRULE$tid
    $SET_X
}
export -f CFG_init


# Deprecated: use CFG_init
init_cfg() {
# Parameter $1: Id of table (may be 0..3)
    if [ "$1" == "0" -o "$1" == "1" -o "$1" == "2" -o "$1" == "3" ]; then
      local tid=$1
    else
      local tid="0"
    fi
    echo $(a_new "$tid")
    eval $(a_active "$tid")
}
export -f init_cfg

# Deprecated: use CFG_init
active_cfg() {
# Parameter $1: Id of table (may be 0..3)
    if [ "$1" == "0" -o "$1" == "1" -o "$1" == "2" -o "$1" == "3" ]; then
      local tid=$1
    else
      local tid="0"
    fi
    echo $(a_active "$tid")
}
export -f active_cfg

set_cfg_def() {
# Parameter $3: Id of table (may be 0..3)
    if [ "$3" == "0" -o "$3" == "1" -o "$3" == "2" -o "$3" == "3" ]; then
      local tid=$3
    else
      local tid="0"
    fi
    CFG_set "$tid" "$1" "$2" "$4" "$5" "$6"
}
export -f set_cfg_def


_read_cfg_file() {
#read_cfg_file(file $tid [section] [-D])    -D means debug
    if [[ ! -n "$1"  || ! -f "$1" ]]; then
      return
    fi
    local key val lne x r t s d b dev
    if [ "$(type -t store_cfg_param_value)" == "function" ]; then
      store_param=store_cfg_param_value
    else
      store_param=CFG_set
    fi
    if [[ $4 =~ (D|1) ]]; then
      dev="_DEV"
    else
      dev=" "
    fi
    t=1
    s=
    d=
    b=
    while IFS="#" read -r lne r || [ -n "$lne" ]; do
      if [ -n "$lne" -a -n "$r" ] && [ "${lne: -1}" != " " ]; then
        lne="$lne#$r"
        r=
      fi
      if [ -n "$lne" ]; then
        if [ "${lne:0:1}" == "[" ]; then
          s="${lne:1: -1}"
          t=0
          if [ "$s" == "_Linux_" ]; then
            t=1
            s="$3"
            d=
          elif [ "$s" == "_${XU_DISTO}_" ]; then
            t=1
            s="$3"
            d=-d
          elif [ "$s" == "_${XU_FH}_" ]; then
            t=1
            s="$3"
            d=-f
          elif [ "$s" == "$3" ]; then
            t=1
            s="$3"
            d=
          elif [ -z "$3" -a "${s:0:1}" != "_" -a "${s:0: -1}" != "_" ]; then
            t=1
            d=
          elif [ "$s" == "_Linux${dev}_" ]; then
            t=1
            s="$3"
            d=
            b=1
          elif [ "$s" == "_${XU_DISTO}${dev}_" ]; then
            t=1
            s="$3"
            d=-d
            b=1
          elif [ "$s" == "_${XU_FH}${dev}_" ]; then
            t=1
            s="$3"
            d=-f
            b=1
          elif [ "$s" == "$3${dev}" ]; then
            t=1
            s="$3"
            d=
            b=1
          fi
        elif [ $t -gt 0 ]; then
          IFS== read -r kk val <<<"$lne"
          kk=$(echo $kk|tr -d "\"' ")
          if [ -n "$kk" ]; then
            val=$(echo $val|tr -d "\"'")
            while [ "${val: -1}" == "\\" ]; do
              IFS=~ read -r x
              x=$(echo $x)
              val="${val:0:-1}$x"
            done
            $store_param $2 "$kk" "$val" "$d" "$b" "$s"
            if [ "$kk" == "CONFN" ]; then
              CONFN="$val"
            fi
          fi
        fi
      fi
    done < "$1"
}

link_cfg() {
# link_cfg(file_cfg [file_def] [tid] [section] [-D])  -D means debug
    if [ "$(echo :$SHELLOPTS:|grep :xtrace: 2>/dev/null)" ]; then set +x; local SET_X="set -x"; else local SET_X=; fi
    if [ "$3" == "0" -o "$3" == "1" -o "$3" == "2" -o "$3" == "3" ]; then
      local tid=$3
    else
      local tid="0"
    fi
    if [ -n "$2" ]; then
      if [ -f $2.sample ]; then
        CFG_set "$tid" "CONFND" "$2.sample"
        _read_cfg_file "$2.sample" "$tid" "$4" "$5"
      fi
      if [ -f $2 ]; then
        CFG_set "$tid" "CONFND" "$2"
        _read_cfg_file "$2" "$tid" "$4" "$5"
      fi
    fi
    if [ -n "$1" ]; then
      CFG_set "$tid" "CONFN" "$1"
      CONFN="$1"
      if [ -f $1.sample ]; then
        CFG_set "$tid" "CONFND" "$1.sample"
        _read_cfg_file "$1.sample" "$tid" "$4" "$5"
      fi
      if [ -f "$CONFN" ]; then
        _read_cfg_file "$CONFN" "$tid" "$4" "$5"
      fi
    fi
    $SET_X
}
export -f link_cfg


##############################################################################
# Parse and manage URI(s) and/or filename
# Parse an URI o filename, default values and return part of URL
# Based on Adam Ryczkowski's solution. BASH_REMATCH contains:
#  0: full value
#  1: prot:
#  2: prot
#  3: //domain
#  4: //
#  5: domain (userinfo+host)
#  6: userinfo@
#  7: userinfo
#  8: host
#  9: : (port introducer)
# 10: port
# 11: /fullpath
# 12: fullpath
# 13: ? (query introducer)
# 14: query
# 15: # (fragment introducer)
# 16: fragment
# 17: dirname (no from regex)
# 18: basename (no from regex)
# 19: name (no from regex)
# 20: ext (no from regex)
#
# Parameter $1:
#    URI or filename to parse
# Parameter $2:
#    URI or filename with default values
# Parameter $3:
#    List of one or more ±KEYWORDS to select or ignore part of URL
#    +ALL      parse all items; must be followed by -KEYWORDS to exclude part of URI
#    ±PROT     include/esclude protocol; i.e. protocol of "http://u@example.com:8080/a/b.c" is "http:"
#    ±DOMAIN   include/esclude domain; i.e. domain of "http://u@example.com:8080/a/b.c" is "u@example.com"
#    ±USER     include/esclude user; i.e. user of "http://u@example.com:8080/a/b.c" is "u"
#    ±HOST     include/esclude host; i.e. host of "http://u@example.com:8080/a/b.c" is "example.com"
#    ±FULLNAME include/esclude fullname; i.e. fullname of "http://u@example.com:8080/a/b.c" is "/a/b"
#    ±DIRNAME  include/esclude dirname; i.e. dirname of "http://u@example.com:8080/a/b.c" is "/a"
#    ±BASENAME include/esclude basename; i.e. basename of "http://u@example.com:8080/a/b.c" is "b.c"
#    ±NAMEID   include/esclude simple nameid; i.e. nameid of "http://u@example.com:8080/a/b.c" is "b"
#    ±EXT      include/esclude extension name; i.e. extension of "http://u@example.com:8080/a/b.c" is ".c"
#    ±PORT     include/esclude port; i.e. port of "http://u@example.com:8080/a/b.c" is "8080"
#    if DOMAIN selected, USER and HOST are ignored
#    if FULLNAME is selected, DIRNAME and BASENAME, NAMEID and EXT are ignored
#    if BASENAME is selected, NAMEID and EXT are ignored
#    +ABS      convert relative FULLNAME to absolute fullname
#    +LOCAL    when URI may be hostname or local filesystem return local filesystem
#
parse_URI() {
#parse_URI(URI default ALL|±USER|±PROT|±DOMAIN|±HOST|±FULLNAME|±DIRNAME|±BASENAME|±NAMEID|±EXT|±PORT)
    local URI_REGEX='^(([^:/?#]+):)?((//)?((([^:/?#]+)@)?([^:/?#]+)))(:([0-9]+))?(/([^?#]*))?(\?([^#]*))?(#(.*))?'
    local IS_URL1='^(([^:/?#]+):)'
    local IS_URL2='^//'
    local IS_MAIL='(([^:/?#]+)@([^:/?#]+))'
    declare -a D V
    if [[ $3 =~ \+LOCAL ]]; then
      if [[ $1 =~ $IS_URL1 || $1 =~ $IS_URL2 ]]; then
        [[ $1 =~ $URI_REGEX ]]; V=("${BASH_REMATCH[@]}")
      else
        V[11]=$1
        [[ "${1:0:1}" == "/" ]] && V[12]=${1:1} || V[12]=$1
      fi
      if [[ $2 =~ $IS_URL1 || $2 =~ $IS_URL2 ]]; then
        [[ $2 =~ $URI_REGEX ]]; D=("${BASH_REMATCH[@]}")
      else
        D[11]=$2
        [[ "${2:0:1}" == "/" ]] && D[12]=${2:1} || D[12]=$2
      fi
    else
      [[ $1 =~ $URI_REGEX ]]; V=("${BASH_REMATCH[@]}")
      [[ $2 =~ $URI_REGEX ]]; D=("${BASH_REMATCH[@]}")
    fi
    if [ -n "${V[11]}" ]; then
      if [[ $3 =~ \+ABS ]]; then
        V[11]=$(readlink -f ${V[11]})
        V[12]=${V[11]:1}
      fi
      V[17]=$(dirname ${V[11]}) || V[17]=
      [[ "${V[17]}" == "." ]] && V[17]=
      V[18]=$(basename ${V[11]}) || V[18]=
      if [ -n "${V[18]}" ]; then
        V[19]="${V[18]%%.*}"
        V[20]="${V[18]#*.}"
        [ "${V[19]}" == "${V[20]}" ] && V[20]=
        [ -n "${V[20]}"  ] && V[20]=".${V[20]}"
      fi
    fi
    if [ -n "${D[11]}" ]; then
      if [[ $3 =~ \+ABS ]]; then
        D[11]=$(readlink -f ${D[11]})
        D[12]=${D[11]:1}
      fi
      D[17]=$(dirname ${D[11]}) || D[17]=
      [[ "${D[17]}" == "." ]] && D[17]=
      D[18]=$(basename ${D[11]}) || D[18]=
      if [ -n "${D[18]}" ]; then
        D[19]="${D[18]%%.*}"
        D[20]="${D[18]#*.}"
        [ "${D[19]}" == "${D[20]}" ] && D[20]=
        [ -n "${D[20]}"  ] && D[20]=".${D[20]}"
      fi
    fi
    if [[ $3 =~ \+DEBUG ]]; then
      echo "<<<$1||$2>>>"
      echo "value        \"${V[0]}\" \"${D[0]}\" \"${BASH_REMATCH[0]}\""
      echo "prot:        \"${V[1]}\" \"${D[1]}\" \"${BASH_REMATCH[1]}\""
      echo "prot         \"${V[2]}\" \"${D[2]}\" \"${BASH_REMATCH[2]}\""
      echo "//domain     \"${V[3]}\" \"${D[3]}\" \"${BASH_REMATCH[3]}\""
      echo "//           \"${V[4]}\" \"${D[4]}\" \"${BASH_REMATCH[4]}\""
      echo "domain       \"${V[5]}\" \"${D[5]}\" \"${BASH_REMATCH[5]}\""
      echo "userinfo@    \"${V[6]}\" \"${D[6]}\" \"${BASH_REMATCH[6]}\""
      echo "userinfo     \"${V[7]}\" \"${D[7]}\" \"${BASH_REMATCH[7]}\""
      echo "host         \"${V[8]}\" \"${D[8]}\" \"${BASH_REMATCH[8]}\""
      echo ":            \"${V[9]}\" \"${D[9]}\" \"${BASH_REMATCH[9]}\""
      echo "port         \"${V[10]}\" \"${D[10]}\" \"${BASH_REMATCH[10]}\""
      echo "path         \"${V[11]}\" \"${D[11]}\" \"${BASH_REMATCH[11]}\""
      echo "rpath        \"${V[12]}\" \"${D[12]}\" \"${BASH_REMATCH[12]}\""
      echo "?            \"${V[13]}\" \"${D[13]}\" \"${BASH_REMATCH[13]}\""
      echo "query        \"${V[14]}\" \"${D[14]}\" \"${BASH_REMATCH[14]}\""
      echo "#            \"${V[15]}\" \"${D[15]}\" \"${BASH_REMATCH[15]}\""
      echo "fragment     \"${V[16]}\" \"${D[16]}\" \"${BASH_REMATCH[16]}\""
      echo "dirname      \"${V[17]}\" \"${D[17]}\" \"${BASH_REMATCH[17]}\""
      echo "basename     \"${V[18]}\" \"${D[18]}\" \"${BASH_REMATCH[18]}\""
      echo "nameid       \"${V[19]}\" \"${D[19]}\" \"${BASH_REMATCH[19]}\""
      echo "ext          \"${V[20]}\" \"${D[20]}\" \"${BASH_REMATCH[20]}\""
      # set -x  #debug
    fi
    URL=
    if [[ ! $3 =~ -PROT && $3 =~ (\+ALL|\+PROT) ]]; then
      if [[ -n "${V[1]}" ]]; then URL="$URL${V[1]}"; else URL="$URL${D[1]}"; fi
    fi
    if [[ ! $3 =~ -DOMAIN ]] && [[ $3 =~ \+DOMAIN ]];then
      if [[ -n "$URL" ]]; then
        if [[ -n "${V[5]}" ]]; then URL="$URL${V[4]}${V[5]}"; else URL="$URL${D[4]}${D[5]}"; fi
      else
        if [[ -n "${V[5]}" ]]; then URL="$URL${V[5]}"; else URL="$URL${D[5]}"; fi
      fi
    else
      if [[ ! $3 =~ -USER ]] && [[ $3 =~ (\+ALL|\+USER) ]];then
        if [[ ! $3 =~ -HOST ]] && [[ $3 =~ (\+ALL|\+HOST) ]];then
          if [[ -n "$URL" ]]; then
            if [[ -n "${V[6]}" ]]; then URL="$URL${V[4]}${V[6]}"; else URL="$URL${D[4]}${D[6]}"; fi
          else
            if [[ -n "${V[6]}" ]]; then URL="$URL${V[6]}"; else URL="$URL${D[6]}"; fi
          fi
          if [[ -n "${V[8]}" ]]; then URL="$URL${V[8]}"; else URL="$URL${D[8]}"; fi
        else
          if [[ -n "$URL" ]]; then
            if [[ -n "${V[7]}" ]]; then URL="$URL${V[4]}${V[7]}"; else URL="$URL${V[4]}${D[7]}"; fi
          else
            if [[ -n "${V[7]}" ]]; then URL="$URL${V[7]}"; else URL="$URL${D[7]}"; fi
          fi
        fi
      elif [[ ! $3 =~ -HOST ]] && [[ $3 =~ \+HOST ]];then
        if [[ -n "$URL" ]]; then
          if [[ -n "${V[8]}" ]]; then URL="$URL${V[4]}${V[8]}"; else URL="$URL${D[4]}${D[8]}"; fi
        else
          if [[ -n "${V[8]}" ]]; then URL="$URL${V[8]}"; else URL="$URL${D[8]}"; fi
        fi
      fi
    fi
    if [[ ! $3 =~ -PORT && $3 =~ (\+ALL|\+PORT) ]]; then
      if [[ -n "$URL" ]]; then
        if [[ -n "${V[9]}" ]]; then URL="$URL${V[9]}"; else URL="$URL${D[9]}"; fi
      else
        if [[ -n "${V[10]}" ]]; then URL="$URL${V[10]}"; else URL="$URL${D[10]}"; fi
      fi
    fi
    if [[ ! $3 =~ -FULLNAME && $3 =~ \+FULLNAME ]]; then
      if [[ -n "${V[17]}" ]]; then URL="$URL${V[17]}"; else URL="$URL${D[17]}"; fi
      [[ -n "$URL" && "${URL: -1}" != "/" ]] && URL="$URL/"
      if [[ -n "${V[19]}" ]]; then URL="$URL${V[19]}"; else URL="$URL${D[19]}"; fi
      if [[ -n "${V[20]}" ]]; then URL="$URL${V[20]}"; else URL="$URL${D[20]}"; fi
    else
      if [[ ! $3 =~ -DIRNAME && $3 =~ (\+ALL|\+DIRNAME) ]]; then
        if [[ -n "${V[17]}" ]]; then URL="$URL${V[17]}"; else URL="$URL${D[17]}"; fi
      fi
      if [[ ! $3 =~ -BASENAME && $3 =~ \+BASENAME ]]; then
        [[ -n "$URL" && "${URL: -1}" != "/" ]] && URL="$URL/"
        if [[ -n "${V[19]}" ]]; then URL="$URL${V[19]}"; else URL="$URL${D[19]}"; fi
        if [[ -n "${V[20]}" ]]; then URL="$URL${V[20]}"; else URL="$URL${D[20]}"; fi
      else
        if [[ ! $3 =~ -NAME && $3 =~ (\+ALL|\+NAME) ]]; then
          [[ -n "$URL" && "${URL: -1}" != "/" ]] && URL="$URL/"
          if [[ -n "${V[19]}" ]]; then URL="$URL${V[19]}"; else URL="$URL${D[19]}"; fi
        fi
        if ! [[ $3 =~ -EXT ]] &&  [[ $3 =~ (\+ALL|\+EXT) ]]; then
          if [[ -n "${V[20]}" ]]; then URL="$URL${V[20]}"; else URL="$URL${D[20]}"; fi
        fi
      fi
    fi
    echo "$URL"
}
export -f parse_URI
